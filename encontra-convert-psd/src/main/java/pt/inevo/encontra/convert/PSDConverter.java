package pt.inevo.encontra.convert;

import org.apache.batik.dom.GenericDOMImplementation;
import org.apache.batik.ext.awt.g2d.GraphicContext;

import org.apache.batik.svggen.*;

import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import psd.base.PsdImage;
import psd.base.PsdObjectBase;
import psd.layer.PsdLayer;

import java.awt.image.BufferedImage;
import java.io.*;
import java.util.*;
import java.util.logging.Logger;

import psd.layer.PsdLayerType;
import psd.layer.PsdTextLayerTypeTool;

import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

public class PSDConverter implements Converter{

    private static Logger log = Logger.getLogger(PSDConverter.class.getName());

    private static String svgNS = "http://www.w3.org/2000/svg";

    public PSDConverter() {}

    public void convertToMimeType(String mimetype, InputStream input, OutputStream output) {

        try {
            PsdImage image = new PsdImage(input);
            List<PsdLayer> imageLayers = image.getLayers();

            // Get a DOMImplementation.
            DOMImplementation domImpl = GenericDOMImplementation.getDOMImplementation();

            // Create an instance of org.w3c.dom.Document.
            Document document = domImpl.createDocument(svgNS, "svg", null);

            // Get the root element (the 'svg' element).
            Element svgRoot = document.getDocumentElement();

            // Set the width and height attributes on the root 'svg' element.
            svgRoot.setAttributeNS(null, "width", String.valueOf(image.getWidth()));
            svgRoot.setAttributeNS(null, "height", String.valueOf(image.getHeight()));
            svgRoot.setAttributeNS(null, "colorMode", String.valueOf(image.getColorMode()));
            svgRoot.setAttributeNS(null, "depth", String.valueOf(image.getDepth()));
            svgRoot.setAttributeNS(null, "channels", String.valueOf(image.getNumberOfChannels()));

            SVGGeneratorContext ctx = SVGGeneratorContext.createDefault(document);
            ctx.setComment("SVG Generated by encontra-convert-psd and Batik SVG Generator");

            // Create an instance of the SVG Generator.
            SVGGraphics2D svgGenerator = new SVGGraphics2D(ctx, true);
            DOMTreeManager domManager = svgGenerator.getDOMTreeManager();

            Map<PsdLayer, List<PsdLayer>> orderedLayers = new TreeMap<PsdLayer, List<PsdLayer>>(new Comparator<PsdLayer>() {
                @Override
                public int compare(PsdLayer o1, PsdLayer o2) {
                    return o1.getName().compareTo(o2.getName());
                }
            });

            /*create a simple hierarchy for the layers to be rendered*/
            for (PsdLayer layer : imageLayers) {
                if (layer.getParent() != null){
                    if (!orderedLayers.containsKey(layer.getParent())){
                        orderedLayers.put(layer.getParent(), new ArrayList<PsdLayer>());
                    }
                    orderedLayers.get(layer.getParent()).add(layer);
                }
            }

            Collection<PsdLayer> keys;
            if (orderedLayers.isEmpty() && image.getLayers().size() > 0){
                keys = image.getLayers();
            } else {
                keys = orderedLayers.keySet();
            }

            /*render all the psd layers in the output stream*/
            if (keys instanceof Set) {
                for (PsdLayer k : keys) {
                    List<PsdLayer> layers = orderedLayers.get(k);

                    Element folderElement = document.createElementNS(svgNS, "g");
                    DOMGroupManager gManager = new DOMGroupManager(svgGenerator.getGraphicContext(), domManager);
                    domManager.appendGroup(folderElement, gManager);

                    folderElement.setAttribute("name", k.getName());
                    folderElement.setAttribute("type", k.getType().toString());

                    for (PsdLayer l : layers) {
                        writeNewLayer(document, svgGenerator, domManager, gManager, l);
                    }
                }
            } else {
                for (PsdLayer l : keys) {
                    writeNewLayer(document, svgGenerator, domManager, null, l);
                }
            }

            boolean useCSS = true; // we want to use CSS style attributes
            Writer out = new OutputStreamWriter(output, "UTF-8");
            svgGenerator.stream(out, useCSS);

        } catch (IOException ex){
            ex.printStackTrace();
        }
    }

    private void writeNewLayer(Document document, SVGGraphics2D svgGenerator, DOMTreeManager domManager, DOMGroupManager gManager, PsdLayer l) {
        Element layer = document.createElementNS(svgNS, "g");
        if (gManager == null)
            gManager = new DOMGroupManager(svgGenerator.getGraphicContext(), domManager);
        gManager.addElement(layer);
        domManager.appendGroup(layer, gManager);

        //set the layer properties
        layer.setAttribute("name", l.getName());
        layer.setAttribute("type", l.getType().toString());
        layer.setAttribute("clip", (l.isClipping()? "auto": "inherit"));
        layer.setAttribute("style", "fill-opacity:" + l.getOpacity());
        if (l.getType().equals(PsdLayerType.HIDDEN)) {
            layer.setAttribute("visibility", "hidden");
        } else if (l.getType().equals(PsdLayerType.NORMAL)) {
            layer.setAttribute("visibility", "visible");
        }

        svgGenerator.drawImage(l.getImage(), l.getLeft(), l.getTop(), l.getWidth(), l.getHeight(), null);
    }
}
